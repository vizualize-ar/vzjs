<html>
  <head>
  </head>
  <body>
    <p>Test the rotator with a 3D model</p>
    <script type="module">
      import * as THREE from "./node_modules/three/build/three.module.js";
      import { RotatorZoom } from "./src/rotator.js";

      let renderer;
      
      const container = document.createElement( 'div' );
      document.body.appendChild( container );

      const scene = new THREE.Scene();
      const camera = createCamera();

      addLight();
      const object = addObjects();
      new RotatorZoom(container, object);
      addRenderer();
      animate();

      window.addEventListener('resize', () =>
      {
        // windowHalfX = window.innerWidth / 2;
        // windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }, false);

      function animate()
      {
        requestAnimationFrame(animate);
        render();
      }

      function render()
      {
        // if (!mouseDown)
        // {
        //   var drag = 0.95;
        //   var minDelta = 0.05;

        //   if (deltaX < -minDelta || deltaX > minDelta)
        //   {
        //     deltaX *= drag;
        //   }
        //   else
        //   {
        //     deltaX = 0;
        //   }

        //   if (deltaY < -minDelta || deltaY > minDelta)
        //   {
        //     deltaY *= drag;
        //   }
        //   else
        //   {
        //     deltaY = 0;
        //   }

        //   handleRotation();
        // }

        renderer.render(scene, camera);
      }

      function createCamera() {
        // const camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.y = 150;
        camera.position.z = 500;

        return camera;
      }

      function addLight() {
        var directionalLight = new THREE.DirectionalLight( 0xffffff, .6 );
        scene.add( directionalLight );
      }

      function addObjects() {
        var boxGeometry = new THREE.BoxGeometry(200, 200, 200);

        for (var i = 0; i < boxGeometry.faces.length; i += 2)
        {

          var color = {
            h: (1 / (boxGeometry.faces.length)) * i,
            s: 0.5,
            l: 0.5
          };

          boxGeometry.faces[i].color.setHSL(color.h, color.s, color.l);
          boxGeometry.faces[i + 1].color.setHSL(color.h, color.s, color.l);

        }

        var cubeMaterial = new THREE.MeshBasicMaterial(
        {
          vertexColors: THREE.FaceColors,
          overdraw: 0.5
        });

        const cube = new THREE.Mesh(boxGeometry, cubeMaterial);
        cube.position.y = 200;
        scene.add(cube);

        return cube;
      }

      function addRenderer() {
        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );
      }
    </script>
  </body>
</html>