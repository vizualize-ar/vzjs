<!-- <html>
    <head>
        <style>
            button {
                margin: 100px 0;
                width: 200px;
                height: 100px;
            }
        </style>
        <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.19/lodash.min.js"></script>
    </head>
    <body>
        <div id="overlay"></div>
        <div id="container"></div>
        <button onclick="startAR()">Start AR</button>
        <script>
            function startAR() {
                new ModelLoader();
            }
        </script>
        <script type="module">
            // import Dat from "./node_modules/dat.gui/build/dat.gui.module.js";
            // import init from "./node_modules/three-dat.gui/dist/index.mjs";
            import * as THREE from 'https://threejs.org/build/three.module.js';

            var MAX_POINTS = 500;
            
            export class ModelLoader {
                width = window.innerWidth;
                height = window.innerHeight;
                
                overlayDiv;
                container;
                camera;
                scene;
                renderer;
                controller;
                
                reticle;
                model;

                hitTestSourceRequested = false;
                hitTestSource;

                constructor() {
                    this.init();
                    this.render();
                }

                async init() {

                    this.initOverlay();
                    this.container = document.getElementById( "container" );
                    this.scene = new THREE.Scene();

                    const directionalLight = new THREE.DirectionalLight( 0xffffff, .6 );
                    this.scene.add( directionalLight );

                    this.camera = new THREE.PerspectiveCamera( 70, this.width / this.height, 0.01, 20 );

                    this.renderer = new THREE.WebGLRenderer();
                    this.renderer.setPixelRatio( window.devicePixelRatio );
                    this.renderer.setSize( this.width, this.height );
                    this.renderer.xr.enabled = true;
                    this.renderer.xr.setReferenceSpaceType( 'local' );

                    this.reticle = new THREE.Mesh(
                        new THREE.RingBufferGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
                        new THREE.MeshBasicMaterial()
                    );
                    this.reticle.matrixAutoUpdate = false;
                    this.reticle.visible = false;
                    this.scene.add( this.reticle );

                    this.container.appendChild( this.renderer.domElement );
                    
                    await this.loadModel();
                    this.initARSession();
                }

                initOverlay() {
                    this.overlayDiv = document.getElementById("overlay");
                    this.overlayDiv.debugOverlay = document.createElement("div");
                    this.overlayDiv.debugOverlay.style.padding = "10px";
                    this.overlayDiv.debugOverlay.style.backgroundColor = "rgb(230, 230, 230, 0.5)";
                    this.overlayDiv.appendChild(this.overlayDiv.debugOverlay);
                }

                initARSession() {
                    const sessionConfig = {
                        requiredFeatures: [ 'hit-test' ],
                        optionalFeatures: [ 'dom-overlay' ],
                        domOverlay: { root: this.overlayDiv }
                    };
                    navigator.xr.requestSession( 'immersive-ar', sessionConfig ).then((session) => {
                        this.renderer.xr.setSession( session );
                        // Enable real world geometry tracking
                        session.updateWorldTrackingState({
                            planeDetectionState : {
                                enabled : true
                            }
                        });
                        this.animate();
                    });
                }

                async loadModel() {
                    const loader = new THREE.TextureLoader();
                    const texture = await loader.loadAsync("./models/tupac.png");
                    var img = new THREE.MeshBasicMaterial({
                        map: texture,
                    });

                    this.model = new THREE.Mesh(new THREE.PlaneGeometry().rotateX( - Math.PI / 2 ), img);
                    // this.model = new THREE.Mesh(
                    //     new THREE.RingBufferGeometry( 0.01, 0.2, 32 ).rotateX( - Math.PI / 2 ),
                    //     // new THREE.MeshBasicMaterial()
                    //     img
                    // );
                    this.model.matrixAutoUpdate = false;
                    this.scene.add(this.model);
                    
                    return Promise.resolve();
                }

                animate() {
                    this.renderer.setAnimationLoop((timestamp, frame) => this.render(timestamp, frame));
                }

                render (timestamp, frame) {

                    if ( frame ) {

                        var referenceSpace = this.renderer.xr.getReferenceSpace();
                        var session = this.renderer.xr.getSession();

                        let detectedPlanes = frame.worldInformation.detectedPlanes;
                        detectedPlanes.forEach(plane => {
                            let planePose = frame.getPose(plane.planeSpace, referenceSpace);
                            let planeVertices = plane.polygon; // plane.polygon is an array of objects containing x,y,z coordinates
                        
                            // ...draw plane_vertices relative to plane_pose...
                            this.drawPlane(planePose, planeVertices);
                        });

                        if (this.hitTestSourceRequested === false) {
                            session.requestReferenceSpace( 'viewer' ).then((referenceSpace) => {
                                session.requestHitTestSource( { space: referenceSpace } ).then(( source ) => {
                                    this.hitTestSource = source;
                                });
                            });

                            session.addEventListener( 'end', () => {
                                this.hitTestSourceRequested = false;
                                this.hitTestSource = null;
                            });

                            this.hitTestSourceRequested = true;
                        }

                        if (this.hitTestSource) {

                            var hitTestResults = frame.getHitTestResults( this.hitTestSource );

                            if ( hitTestResults.length ) {
                                var hit = hitTestResults[ 0 ];
                                const pose = hit.getPose( referenceSpace );
                                this.logObject("Pose", {
                                    matrix: pose.transform.matrix,
                                    orientation: pose.transform.orientation,
                                    position: pose.transform.position
                                });
                                const hitMatrix = pose.transform.matrix;
                                
                                // this.reticle.matrix.fromArray( hitMatrix );
                                // this.reticle.visible = true;

                                // const mat = new THREE.Matrix4();
                                // mat.fromArray( hitMatrix );
                                // this.model.position.setFromMatrixPosition(mat);
                                // this.model.rotation.setFromRotationMatrix(mat);
                                
                                this.model.matrix.fromArray(hitMatrix);
                                this.model.visible = true;

                                this.reticle.updateMatrixWorld();
								//this.reticle.matrixWorldNeedsUpdate = true;
								
								var pos = new THREE.Vector3();
								var quat = new THREE.Quaternion();
								this.reticle.getWorldPosition(pos)
								this.reticle.getWorldQuaternion(quat)
								// console.log(pos)
								
								this.model.position.copy(pos);
								this.model.lookAt(this.camera.position);
								this.model.visible = true;

                            } else {
                                this.reticle.visible = false;
                                this.model.visible = false;
                            }
                        } else {
                            this.reticle.visible = false;
                            this.model.visible = false;
                        }
                    }

                    this.renderer.render(this.scene, this.camera);
                }

                prevLine = null;
                drawPlane(pose, vertices) {
                    // geometry
                    var geometry = new THREE.BufferGeometry();

                    // attributes
                    var positions = new Float32Array( MAX_POINTS * 3 ); // 3 vertices per point
                    var index = 0;
                    for ( var i = 0; i < vertices.length;  i ++ ) {
                        positions[ index ++ ] = vertices[i].x;
                        positions[ index ++ ] = vertices[i].y;
                        positions[ index ++ ] = vertices[i].z;
                    }
                    geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
                    
                    // drawCalls
                    geometry.setDrawRange( 0, vertices.length );

                    // material
                    var material = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 2 } );

                    // line
                    const line = new THREE.Line( geometry,  material );
                    
                    // var positions = line.geometry.attributes.position.array;                        
                    // var index = 0;
                    // for ( var i = 0; i < vertices.length;  i ++ ) {
                    //     positions[ index ++ ] = vertices[i].x;
                    //     positions[ index ++ ] = vertices[i].y;
                    //     positions[ index ++ ] = vertices[i].z;
                    // }
                    // line.geometry.setDrawRange( 0, vertices.length );

                    // Set position relative to pose
                    const poseMatrix = pose.transform.matrix;

                    const mat = new THREE.Matrix4();
                    mat.fromArray( poseMatrix );
                    line.position.setFromMatrixPosition(mat);
                    line.rotation.setFromRotationMatrix(mat);
                    
                    if (this.prevLine) {
                        this.scene.remove(this.prevLine);
                    }
                    this.scene.add(line);
                    this.prevLine = line;
                }

                logKeyValue(msg, obj) {
                    let message = "";
                    message += this.generateKVMessage(message, obj);
                    this.overlayDiv.debugOverlay.innerHTML = msg + ":<br>" + message;
                }

                generateKVMessage(msg, obj) {
                    // for(const key of Object.keys(obj)) {
                    for(const key in obj) {
                        if (typeof obj[key] === 'object') {
                            msg += `${key}: ${this.generateKVMessage(msg, obj[key])}<br>`;
                        } else {
                            msg += `${key}: ${obj[key]}<br>`;
                        }
                    }
                    return msg;
                }

                logObject(msg, obj) {
                    console.log(msg, obj);
                    this.overlayDiv.debugOverlay.innerHTML = msg + ":<div><pre><code>" + JSON.stringify(_.cloneDeep(obj), null, 2) + "</code></pre></div>";
                }
            }

            window.ModelLoader = ModelLoader;
        </script>
    </body>
</html> -->